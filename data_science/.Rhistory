),x = rightSide$x,y = rightSide$y,z = rightSide$z)
rightSide = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide$x,y = rightSide$y,z = rightSide$z)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
uXP = crossProduct(imu_and_kinect$kinect_hand_right_orientation.x, imu_and_kinect$kinect_hand_right_orientation.x, imu_and_kinect$kinect_hand_right_orientation.x, imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide$x,y = rightSide$y,z = rightSide$z)
uXP = crossProduct(qp$x,qp$y,qp$z,kinect_hand_right_orientation.x,kinect_hand_right_orientation.y,kinect_hand_right_orientation.z)
rightSide_qp_q = qp$w * c(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z) + uXp
uXP = crossProduct(qp$x,qp$y,qp$z,kinect_hand_right_orientation.x,kinect_hand_right_orientation.y,kinect_hand_right_orientation.z)
uxP = crossProduct(qp$x,qp$y,qp$z,kinect_hand_right_orientation.x,kinect_hand_right_orientation.y,kinect_hand_right_orientation.z)
uxP = crossProduct(qp$x,qp$y,qp$z,
imu_and_kinect$kinect_hand_right_orientation.x,
imu_and_kinect$kinect_hand_right_orientation.y,
imu_and_kinect$kinect_hand_right_orientation.z)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide$x,y = rightSide$y,z = rightSide$z)
uxP = crossProduct(qp$x,qp$y,qp$z,
imu_and_kinect$kinect_hand_right_orientation.x,
imu_and_kinect$kinect_hand_right_orientation.y,
imu_and_kinect$kinect_hand_right_orientation.z)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide$x,y = rightSide$y,z = rightSide$z)
uXP = crossProduct(qp$x,qp$y,qp$z,
imu_and_kinect$kinect_hand_right_orientation.x,
imu_and_kinect$kinect_hand_right_orientation.y,
imu_and_kinect$kinect_hand_right_orientation.z)
rightSide_qp_q = qp$w * c(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z) + uXp
rightSide_qp_q = qp$w * c(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z) + uXP
# Ist das Skalarprodukt hier überhaupt notwendig??
qp_q = data.frame(w = scalarProduct(
-qp$x,
-qp$y,
-qp$z,
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z
), x = rightSide_qp_q$x, y = rightSide_qp_q$y, rightSide_qp_q$z)
rotatedValues = data.frame(x = rightSide_qp_q$x, y = rightSide_qp_q$y, rightSide_qp_q$z)
View(rotatedValues)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide$x,y = rightSide$y,z = rightSide$z)
uXP = crossProduct(qp$x,qp$y,qp$z,
imu_and_kinect$kinect_hand_right_orientation.x,
imu_and_kinect$kinect_hand_right_orientation.y,
imu_and_kinect$kinect_hand_right_orientation.z)
rightSide_qp_q = qp$w * c(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z) + uXP
# Ist das Skalarprodukt hier überhaupt notwendig??
qp_q = data.frame(w = scalarProduct(
-qp$x,
-qp$y,
-qp$z,
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z
), x = rightSide_qp_q$x, y = rightSide_qp_q$y, z = rightSide_qp_q$z)
rotatedValues = data.frame(x = rightSide_qp_q$x, y = rightSide_qp_q$y, rightSide_qp_q$z)
rightSide_qp = imu_and_kinect$kinect_hand_left_orientation.w * c(imu_and_kinect$imu_acceleration.x, imu_and_kinect$imu_acceleration.y, imu_and_kinect$imu_acceleration.z) + uXP
qp = data.frame(w = scalarProduct(
-imu_and_kinect$kinect_hand_right_orientation.x,
-imu_and_kinect$kinect_hand_right_orientation.y,
-imu_and_kinect$kinect_hand_right_orientation.z,
imu_and_kinect$imu_acceleration.x,
imu_and_kinect$imu_acceleration.y,
imu_and_kinect$imu_acceleration.z
),x = rightSide_qp$x,y = rightSide_qp$y,z = rightSide_qp$z)
uXP = crossProduct(qp$x,qp$y,qp$z,
imu_and_kinect$kinect_hand_right_orientation.x,
imu_and_kinect$kinect_hand_right_orientation.y,
imu_and_kinect$kinect_hand_right_orientation.z)
View(processModel)
processModel[["Q"]]
processModel = get10DimensionsAccelerationModel(
c(params$x_initial_sx,
params$x_initial_vy,
params$x_initial_ax,
params$x_initial_sy,
params$x_initial_vy,
params$x_initial_ay,
params$x_initial_sz,
params$x_initial_vz,
params$x_initial_az,
params$x_initial_g),
diag(c(
params$initial_belief_11,
params$initial_belief_22,
params$initial_belief_33,
params$initial_belief_44,
params$initial_belief_55,
params$initial_belief_66,
params$initial_belief_77,
params$initial_belief_88,
params$initial_belief_99,
params$initial_belief_00)))
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
get10DimensionsAccelerationModel <- function(initialState, initialBelief){
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
processModel$A = matrix(data = c(
1,Ts,Ts**2,0,0,0,      0,0,0,      0,
0,1,Ts,    0,0,0,      0,0,0,      0,
0,0,1,     0,0,0,      0,0,0,      0,
0,0,0,     1,Ts,Ts**2, 0,0,0,      0,
0,0,0,     0,1,Ts,     0,0,0,      0,
0,0,0,     0,0,1,      0,0,0,      0,
0,0,0,     0,0,0,      1,Ts,Ts**2, 0,
0,0,0,     0,0,0,      0,1,Ts,     0,
0,0,0,     0,0,0,      0,0,1,      0,
0,0,0,     0,0,0,      0,0,0,      1
)
,nrow = 10, ncol = 10, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 10, ncol = 1) ## state vector
processModel$C = matrix(data = c(
1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,
0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,1,1
), nrow = 6, ncol = 9, byrow=TRUE) ## observation/ measurment vector
Q = matrix(data = c(
params$process_noise_sigma_x**2,0,0,
0,params$process_noise_sigma_y**2,0,
0,0,params$process_noise_sigma_z**2
), nrow = 3, ncol = 3, byrow=TRUE)
processModel$Gd = matrix(data = c(
Ts**2/2,0,0,
Ts,     0,0,
1,      0,0,
0,Ts**2/2,0,
0,Ts,     0,
0,1,      0,
0,0,Ts**2/2,
0,0,Ts     ,
0,0,1      ,
0,0,0
), nrow=10, ncol=3, byrow = TRUE)
processModel$Q = processModel$Gd %*% Q %*% t(processModel$Gd)
processModel$P = initialBelief
processModel$R = matrix(data = c(params$sensor_noise_kinect_sigma_x**2,0,0,0,0,0,
0,params$sensor_noise_kinect_sigma_y**2,0,0,0,0,
0,0,params$sensor_noise_kinect_sigma_z**2,0,0,0,
0,0,0,params$sensor_noise_imu_sigma_x**2,0,0,
0,0,0,0,params$sensor_noise_imu_sigma_y**2,0,
0,0,0,0,0,params$sensor_noise_imu_sigma_z**2
), nrow = 6, ncol = 6)
processModel$colNames = c("x","v_x","a_x","y","v_y","a_y","z","v_z","a_z")
return(processModel)
}
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
processModel = get10DimensionsAccelerationModel(
c(params$x_initial_sx,
params$x_initial_vy,
params$x_initial_ax,
params$x_initial_sy,
params$x_initial_vy,
params$x_initial_ay,
params$x_initial_sz,
params$x_initial_vz,
params$x_initial_az,
params$x_initial_g),
diag(c(
params$initial_belief_11,
params$initial_belief_22,
params$initial_belief_33,
params$initial_belief_44,
params$initial_belief_55,
params$initial_belief_66,
params$initial_belief_77,
params$initial_belief_88,
params$initial_belief_99,
params$initial_belief_00)))
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
get10DimensionsAccelerationModel <- function(initialState, initialBelief){
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
processModel$A = matrix(data = c(
1,Ts,Ts**2,0,0,0,      0,0,0,      0,
0,1,Ts,    0,0,0,      0,0,0,      0,
0,0,1,     0,0,0,      0,0,0,      0,
0,0,0,     1,Ts,Ts**2, 0,0,0,      0,
0,0,0,     0,1,Ts,     0,0,0,      0,
0,0,0,     0,0,1,      0,0,0,      0,
0,0,0,     0,0,0,      1,Ts,Ts**2, 0,
0,0,0,     0,0,0,      0,1,Ts,     0,
0,0,0,     0,0,0,      0,0,1,      0,
0,0,0,     0,0,0,      0,0,0,      1
)
,nrow = 10, ncol = 10, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 10, ncol = 1) ## state vector
processModel$C = matrix(data = c(
1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,
0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,1,1
), nrow = 6, ncol = 9, byrow=TRUE) ## observation/ measurment vector
Q = matrix(data = c(
params$process_noise_sigma_x**2,0,0,
0,params$process_noise_sigma_y**2,0,
0,0,params$process_noise_sigma_z**2
), nrow = 3, ncol = 3, byrow=TRUE)
processModel$Gd = matrix(data = c(
Ts**2/2,0,0,
Ts,     0,0,
1,      0,0,
0,Ts**2/2,0,
0,Ts,     0,
0,1,      0,
0,0,Ts**2/2,
0,0,Ts     ,
0,0,1
), nrow=9, ncol=3, byrow = TRUE)
processModel$Q = processModel$Gd %*% Q %*% t(processModel$Gd)
processModel$P = initialBelief
processModel$R = matrix(data = c(params$sensor_noise_kinect_sigma_x**2,0,0,0,0,0,
0,params$sensor_noise_kinect_sigma_y**2,0,0,0,0,
0,0,params$sensor_noise_kinect_sigma_z**2,0,0,0,
0,0,0,params$sensor_noise_imu_sigma_x**2,0,0,
0,0,0,0,params$sensor_noise_imu_sigma_y**2,0,
0,0,0,0,0,params$sensor_noise_imu_sigma_z**2
), nrow = 6, ncol = 6)
processModel$colNames = c("x","v_x","a_x","y","v_y","a_y","z","v_z","a_z")
return(processModel)
}
processModel = get10DimensionsAccelerationModel(
c(params$x_initial_sx,
params$x_initial_vy,
params$x_initial_ax,
params$x_initial_sy,
params$x_initial_vy,
params$x_initial_ay,
params$x_initial_sz,
params$x_initial_vz,
params$x_initial_az,
params$x_initial_g),
diag(c(
params$initial_belief_11,
params$initial_belief_22,
params$initial_belief_33,
params$initial_belief_44,
params$initial_belief_55,
params$initial_belief_66,
params$initial_belief_77,
params$initial_belief_88,
params$initial_belief_99,
params$initial_belief_00)))
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
get10DimensionsAccelerationModel <- function(initialState, initialBelief){
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
processModel$A = matrix(data = c(
1,Ts,Ts**2,0,0,0,      0,0,0,      0,
0,1,Ts,    0,0,0,      0,0,0,      0,
0,0,1,     0,0,0,      0,0,0,      0,
0,0,0,     1,Ts,Ts**2, 0,0,0,      0,
0,0,0,     0,1,Ts,     0,0,0,      0,
0,0,0,     0,0,1,      0,0,0,      0,
0,0,0,     0,0,0,      1,Ts,Ts**2, 0,
0,0,0,     0,0,0,      0,1,Ts,     0,
0,0,0,     0,0,0,      0,0,1,      0,
0,0,0,     0,0,0,      0,0,0,      1
)
,nrow = 10, ncol = 10, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 10, ncol = 1) ## state vector
processModel$C = matrix(data = c(
1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,
0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,1,1
), nrow = 6, ncol = 10, byrow=TRUE) ## observation/ measurment vector
Q = matrix(data = c(
params$process_noise_sigma_x**2,0,0,
0,params$process_noise_sigma_y**2,0,
0,0,params$process_noise_sigma_z**2
), nrow = 3, ncol = 3, byrow=TRUE)
processModel$Gd = matrix(data = c(
Ts**2/2,0,0,
Ts,     0,0,
1,      0,0,
0,Ts**2/2,0,
0,Ts,     0,
0,1,      0,
0,0,Ts**2/2,
0,0,Ts     ,
0,0,1
), nrow=9, ncol=3, byrow = TRUE)
processModel$Q = processModel$Gd %*% Q %*% t(processModel$Gd)
processModel$P = initialBelief
processModel$R = matrix(data = c(params$sensor_noise_kinect_sigma_x**2,0,0,0,0,0,
0,params$sensor_noise_kinect_sigma_y**2,0,0,0,0,
0,0,params$sensor_noise_kinect_sigma_z**2,0,0,0,
0,0,0,params$sensor_noise_imu_sigma_x**2,0,0,
0,0,0,0,params$sensor_noise_imu_sigma_y**2,0,
0,0,0,0,0,params$sensor_noise_imu_sigma_z**2
), nrow = 6, ncol = 6)
processModel$colNames = c("x","v_x","a_x","y","v_y","a_y","z","v_z","a_z")
return(processModel)
}
processModel = get10DimensionsAccelerationModel(
c(params$x_initial_sx,
params$x_initial_vy,
params$x_initial_ax,
params$x_initial_sy,
params$x_initial_vy,
params$x_initial_ay,
params$x_initial_sz,
params$x_initial_vz,
params$x_initial_az,
params$x_initial_g),
diag(c(
params$initial_belief_11,
params$initial_belief_22,
params$initial_belief_33,
params$initial_belief_44,
params$initial_belief_55,
params$initial_belief_66,
params$initial_belief_77,
params$initial_belief_88,
params$initial_belief_99,
params$initial_belief_00)))
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
get10DimensionsAccelerationModel <- function(initialState, initialBelief){
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
processModel$A = matrix(data = c(
1,Ts,Ts**2,0,0,0,      0,0,0,      0,
0,1,Ts,    0,0,0,      0,0,0,      0,
0,0,1,     0,0,0,      0,0,0,      0,
0,0,0,     1,Ts,Ts**2, 0,0,0,      0,
0,0,0,     0,1,Ts,     0,0,0,      0,
0,0,0,     0,0,1,      0,0,0,      0,
0,0,0,     0,0,0,      1,Ts,Ts**2, 0,
0,0,0,     0,0,0,      0,1,Ts,     0,
0,0,0,     0,0,0,      0,0,1,      0,
0,0,0,     0,0,0,      0,0,0,      1
)
,nrow = 10, ncol = 10, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 10, ncol = 1) ## state vector
processModel$C = matrix(data = c(
1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,
0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,1,1
), nrow = 6, ncol = 10, byrow=TRUE) ## observation/ measurment vector
Q = matrix(data = c(
params$process_noise_sigma_x**2,0,0,
0,params$process_noise_sigma_y**2,0,
0,0,params$process_noise_sigma_z**2
), nrow = 3, ncol = 3, byrow=TRUE)
processModel$Gd = matrix(data = c(
Ts**2/2,0,0,
Ts,     0,0,
1,      0,0,
0,Ts**2/2,0,
0,Ts,     0,
0,1,      0,
0,0,Ts**2/2,
0,0,Ts     ,
0,0,1      ,
0,0,0
), nrow=10, ncol=3, byrow = TRUE)
processModel$Q = processModel$Gd %*% Q %*% t(processModel$Gd)
processModel$P = initialBelief
processModel$R = matrix(data = c(params$sensor_noise_kinect_sigma_x**2,0,0,0,0,0,
0,params$sensor_noise_kinect_sigma_y**2,0,0,0,0,
0,0,params$sensor_noise_kinect_sigma_z**2,0,0,0,
0,0,0,params$sensor_noise_imu_sigma_x**2,0,0,
0,0,0,0,params$sensor_noise_imu_sigma_y**2,0,
0,0,0,0,0,params$sensor_noise_imu_sigma_z**2
), nrow = 6, ncol = 6)
processModel$colNames = c("x","v_x","a_x","y","v_y","a_y","z","v_z","a_z")
return(processModel)
}
processModel = get10DimensionsAccelerationModel(
c(params$x_initial_sx,
params$x_initial_vy,
params$x_initial_ax,
params$x_initial_sy,
params$x_initial_vy,
params$x_initial_ay,
params$x_initial_sz,
params$x_initial_vz,
params$x_initial_az,
params$x_initial_g),
diag(c(
params$initial_belief_11,
params$initial_belief_22,
params$initial_belief_33,
params$initial_belief_44,
params$initial_belief_55,
params$initial_belief_66,
params$initial_belief_77,
params$initial_belief_88,
params$initial_belief_99,
params$initial_belief_00)))
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
processModel$Q)
processModel$Q
processModel$C
processModel$x
View(processModel)
processModel[["Q"]]
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
processModel$q[10,10] = 1
processModel$Q[10,10] = 1
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
processModel$Q[10,10] = 0.1
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$A, R = processModel$R)
dlmFilterResult = dlm::dlmFilter(
rbind(
interpolatedKinectValues$x[data_lower_lim:data_upper_lim],
interpolatedKinectValues$y[data_lower_lim:data_upper_lim],
interpolatedKinectValues$z[data_lower_lim:data_upper_lim],
rotatedValues$x[data_lower_lim:data_upper_lim],
rotatedValues$y[data_lower_lim:data_upper_lim],
rotatedValues$z[data_lower_lim:data_upper_lim]
), dlmFusionModel, debug = FALSE, simplify = FALSE
)
dlmFilterResult = dlm::dlmFilter(
rbind(
interpolatedKinectValues$x[data_lower_lim:data_upper_lim],
interpolatedKinectValues$y[data_lower_lim:data_upper_lim],
interpolatedKinectValues$z[data_lower_lim:data_upper_lim],
rotatedValues$x[data_lower_lim:data_upper_lim],
rotatedValues$y[data_lower_lim:data_upper_lim],
rotatedValues$z[data_lower_lim:data_upper_lim]
), dlmFusionModel, debug = FALSE, simplify = FALSE
)
View(resultDlmFusion)
View(rotatedValues)
