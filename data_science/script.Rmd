---
title: "Improving inertial Measurement data with visual sensor data from Kinect Camera (only imu)"
params: 
  imu_initial_sx: 10
  imu_initial_sy: 10
  imu_initial_sz: 180
  imu_initial_vx: 10
  imu_initial_vy: 10
  imu_initial_vz: 180
  imu_initial_belief_11: 1
  imu_initial_belief_22: 1
  imu_initial_belief_33: 1
  imu_initial_belief_44: 0
  imu_initial_belief_55: 0
  imu_initial_belief_66: 0
  imu_q_sigma_x: 0.01
  imu_q_sigma_y: 0.01
  imu_q_sigma_z: 0.01
  imu_r_sigma_x: 10
  imu_r_sigma_y: 10
  imu_r_sigma_z: 10
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Execute this chunk to load install the required libraries

```{r}
#install.packages("RMThreshold")
#install.packages("jsonlite")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("patchwork")
#install.packages("reshape2")
#install.packages("RSpincalc")
#install.packages("LaplacesDemon")
#install.packages('Rcpp')

```


Execute this chunk of code to load all the libraries

```{r}
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
```

Execute this line of code to load all the functions

```{r}
interpolateDataChunk <- function(index, chunk){
  if(index == 1){
    index_of_first_non_zero = subset(data.frame(i = 1:length(chunk), x = chunk), x != 0)[1,1]
    chunk[0:(index_of_first_non_zero-1)] = chunk[index_of_first_non_zero]
    return(chunk[1:index_of_first_non_zero])
  }
  else{
    if(length(chunk) == 2)
      return(chunk[1])
    else if(length(chunk) > 2)
      numberOfIncrements = length(chunk[2:(length(chunk))])
    interpolationIncrement = (chunk[length(chunk)] - chunk[1]) / numberOfIncrements
    return(c(chunk[1], chunk[1] + 1:(numberOfIncrements-1) * interpolationIncrement))
  }
}

accumulateChunks <- function(vals){
  if(vals[1] == 0) {
  } else {
    index_of_first_non_zero = subset(data.frame(i = 1:length(vals), x = vals), x != 0)[1,1]
    index_of_second_non_zero = subset(data.frame(i = 1:(length(vals)-1), x = vals[(index_of_first_non_zero+1):length(vals)]), x != 0)[1,1]
    if(is.na(index_of_second_non_zero)){
      vals[length(vals)] = vals[index_of_first_non_zero]
      return(list(vals))
    } else {
      return(list(vals[index_of_first_non_zero:(index_of_second_non_zero+1)]))
    }
  }
}

# Function to interpolate values inbetween
interpolateZeroesInbetween <- function(measurements){
  chunks = list()
  measurements_temp=measurements
  for(v in 1:length(measurements)){
    if(length(measurements_temp) > 1){
      chunks[v] = accumulateChunks(measurements_temp)
      measurements_temp = measurements_temp[2:length(measurements_temp)]
    }
  }
  names(chunks) <- seq_along(chunks)
  chunks[sapply(chunks, is.null)] <- NULL
  return(unlist(mapply(interpolateDataChunk, 1:length(chunks), chunks)))
}

```

To load the model for the kalman execute this line

```{r}
get6AxisOfFreedomVelocityModel <- function(initialState, initialBelief, isPositionSensor = FALSE, isAccelerationSensor = FALSE){
  #Currently used variable names -> variable names from Slides
  # F -> A: State Transition Matrix
  # a -> x: State Vector
  # H -> C: Observation Matrix
  # Q -> Q: Process Noise Matrix
  # R -> R: Sensor Noise Matrix
  # P -> P: Sensor Belief
  
  velocityModel = list()
  dt = 0.014
  velocityModel$F = matrix(data = c(
    1,0,0,dt,0,0,
    0,1,0,0,dt,0,
    0,0,1,0,0,dt,
    0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1
  )
  ,nrow = 6, ncol = 6, byrow=TRUE)
  
  velocityModel$a = matrix(data = initialState, nrow = 6, ncol = 1) ## state vector
  
  if(isAccelerationSensor){
    velocityModel$H = matrix(data = c(
      0,0,0,1,0,0,
      0,0,0,0,1,0,
      0,0,0,0,0,1
    ), nrow = 3, ncol = 6) ## observation/ measurment vector 
  }
  if(isPositionSensor) {
    velocityModel$H = matrix(data = c(
      1,0,0,0,0,0,
      0,1,0,0,0,0,
      0,0,1,0,0,0
    ), nrow = 3, ncol = 6, byrow=TRUE) ## observation/ measurment vector  
  }
  
  #velocityModel$Q = add.Gaussian.noise(matrix(data = 1,nrow = 6, ncol = 6), mean = 0, stddev = 2) ## white noise as process noise
  
  Q = matrix(data = c(
    params$imu_q_sigma_x**2,0,0,
    0,params$imu_q_sigma_y**2,0,
    0,0,params$imu_q_sigma_z**2
  ), nrow = 3, ncol = 3, byrow=TRUE)
  
  velocityModel$Gd = matrix(data =c(
    dt**2/2, 0, 0, dt**2/2, 0, 0,
    0, dt**2/2, 0, 0, dt**2/2, 0,
    0, 0, dt**2/2, 0, 0, dt**2/2,
    dt, 0, 0, dt, 0, 0,
    0, dt, 0, 0, dt, 0,
    0, 0, dt, 0, 0, dt
  ), nrow=6, ncol=3, byrow = TRUE)
  
  velocityModel$Q = velocityModel$Gd %*% Q %*% t(velocityModel$Gd)
  
  velocityModel$P = initialBelief  
  
  x_sigma = params$imu_r_sigma_x; xy_sigma = 0; xz_sigma = 0 
  yx_sigma = 0; y_sigma = params$imu_r_sigma_y; yz_sigma = 0 
  zx_sigma = 0; zy_sigma = 0; z_sigma = params$imu_r_sigma_z
  
  
  velocityModel$R = matrix(data = c(x_sigma**2, xy_sigma, xz_sigma, 
                                    yx_sigma, y_sigma**2, yz_sigma, 
                                    zx_sigma, zy_sigma, z_sigma**2
  ), nrow = 3, ncol = 3) 
  
  velocityModel$colNames = c("x","y","z","v_x","v_y","v_z")
  
  return(velocityModel)
}
get6degFusion <- function(initialState, initialBelief){
  velocityModel = list()
  dt = 0.014
  velocityModel$F = matrix(data = c(
    1,0,0,dt,0,0,
    0,1,0,0,dt,0,
    0,0,1,0,0,dt,
    0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1
  )
  ,nrow = 6, ncol = 6, byrow=TRUE)
  
  velocityModel$a = matrix(data = initialState, nrow = 6, ncol = 1) ## state vector
  
  velocityModel$H = matrix(data = c(
    1,0,0,0,0,0,
    0,1,0,0,0,0,  
    0,0,1,0,0,0,
    0,0,0,10,0,0,
    0,0,0,0,10,0,
    0,0,0,0,0,1000
  ), nrow = 6, ncol = 6, byrow=TRUE) ## observation/ measurement vector 
  
  #velocityModel$Q = add.Gaussian.noise(matrix(data = 1,nrow = 6, ncol = 6), mean = 0, stddev = 2) ## white noise as process noise
  velocityModel$P = initialBelief  
  
  x_sigma = 0.02; y_sigma = 0.02; z_sigma = 0.02
  vx_sigma = 0.02; vy_sigma = 0.02; vz_sigma = 0.02
  
  Q = matrix(data = c(
    1,0,0,0,0,0,
    0,1,0,0,0,0,
    0,0,1,0,0,0,
    0,0,0,10**2,0,0,
    0,0,0,0,10**2,0,
    0,0,0,0,0,0.5**2
  ), nrow = 6, ncol = 6, byrow=TRUE)
  
  velocityModel$Gd = matrix(data =c(
    dt**2/2, 0, 0, 0, 0, 0,
    0, dt**2/2, 0, 0, 0, 0,
    0, 0, dt**2/2, 0, 0, 0,
    dt,0,0, dt, 0, 0,
    0,0,0, 0, dt, 0,
    0,0,0, 0, 0, dt
  ), nrow=6, ncol=6, byrow = TRUE)
  
  velocityModel$Q = velocityModel$Gd %*% Q %*% t(velocityModel$Gd)
  
  
  velocityModel$R = diag(c(x_sigma**2, y_sigma**2, z_sigma**2, vx_sigma**2, vy_sigma**2, vz_sigma**2))
  
  velocityModel$colNames = c("x","v_x","y","v_y","z","v_z")
  
  return(velocityModel)
}
```

```{r}
kalman_init <- function(x,P,Q,H,F,R){
  kalmanFilter <- list()
  
  kalmanFilter$x = x
  kalmanFilter$P = P
  kalmanFilter$Q = Q
  kalmanFilter$H = H
  kalmanFilter$R = R
  kalmanFilter$K = P %*% t(H) %*% solve(H %*% P %*% t(H) + R)
  kalmanFilter$F = F
  
  class(kalmanFilter) = "kalmanFilter"
  
  return(kalmanFilter)
}

dlm_init <- function(x,P,Q,H,F,R){
  kalmanFilter <- list()
  
  kalmanFilter$x = x
  kalmanFilter$P = P
  kalmanFilter$Q = Q
  kalmanFilter$H = H
  kalmanFilter$R = R
  kalmanFilter$K = P %*% t(H) %*% solve(H %*% P %*% t(H) + R)
  kalmanFilter$F = F
  
  #V, W (covariance matrices of the measurement and state equations, respectively)
  # FF and GG (measurement equation matrix and transition matrix respectively)
  # m0, C0 (prior mean and covariance matrix of the state vector)
  
  
  return(dlm::dlm(FF = H, V = R, GG = F, W = Q, m0 = x, C0 = P))
}
```


To load the data from the sensors execute this snippet of code 

```{r}
imu_and_kinect <- read.csv2("D:/Projekte/Digital-Identity/data_science/imu_and_kinect.csv")
```


Here are some operations on the raw kinect data, to interpolate values
```{r}
interpolated_kinect_foot_right_x = interpolateZeroesInbetween(imu_and_kinect$kinect_foot_right.x)
interpolated_kinect_foot_right_x = c(interpolated_kinect_foot_right_x[1], interpolated_kinect_foot_right_x, last(interpolated_kinect_foot_right_x))
interpolated_kinect_foot_right_y = interpolateZeroesInbetween(imu_and_kinect$kinect_foot_right.y)
interpolated_kinect_foot_right_y = c(interpolated_kinect_foot_right_y[1], interpolated_kinect_foot_right_y, last(interpolated_kinect_foot_right_y))
interpolated_kinect_foot_right_z = interpolateZeroesInbetween(imu_and_kinect$kinect_foot_right.z)
interpolated_kinect_foot_right_z = c(interpolated_kinect_foot_right_z[1], interpolated_kinect_foot_right_z, last(interpolated_kinect_foot_right_z))

interpolated_kinect_hand_right_x = interpolateZeroesInbetween(imu_and_kinect$kinect_hand_right.x)
interpolated_kinect_hand_right_x = c(interpolated_kinect_hand_right_x[1], interpolated_kinect_hand_right_x, last(interpolated_kinect_hand_right_x))
interpolated_kinect_hand_right_y = interpolateZeroesInbetween(imu_and_kinect$kinect_hand_right.y)
interpolated_kinect_hand_right_y = c(interpolated_kinect_hand_right_y[1], interpolated_kinect_hand_right_y, last(interpolated_kinect_hand_right_y))
interpolated_kinect_hand_right_z = interpolateZeroesInbetween(imu_and_kinect$kinect_hand_right.z)
interpolated_kinect_hand_right_z = c(interpolated_kinect_hand_right_z[1], interpolated_kinect_hand_right_z, last(interpolated_kinect_hand_right_z))

# Zeit in Millisekunden ?bersetzen

imu_and_kinect$t = (imu_and_kinect$t.m * 60 * 1000 + imu_and_kinect$t.s * 1000 + imu_and_kinect$t.ms)

# Erstelle Data Frame f?r kinect daten
# Darauf achten das datens?tze gleiche L?nge aufweisen

interpolatedKinectValues = data.frame(
  t = imu_and_kinect$t[1:length(imu_and_kinect$t)-1],
  x = interpolated_kinect_hand_right_x,
  y = interpolated_kinect_hand_right_y,
  z = interpolated_kinect_hand_right_z
)

```

Init the state space models

```{r}
data_lower_lim = 0
data_upper_lim = 2200


processModelImu = get6AxisOfFreedomVelocityModel(
  c(params$imu_initial_sx,
    params$imu_initial_sy,
    params$imu_initial_sz, 
    params$imu_initial_vx, 
    params$imu_initial_vy, 
    params$imu_initial_vz),
  diag(c(
    params$imu_initial_belief_11,
    params$imu_initial_belief_22,
    params$imu_initial_belief_33,
    params$imu_initial_belief_44,
    params$imu_initial_belief_55,
    params$imu_initial_belief_66)), isAccelerationSensor = TRUE)
#processModelImu = get6AxisOfFreedomVelocityModel(c(0,0,180000, 0, 0, 18000), diag(c(1,1,1,0,0,0)), isAccelerationSensor = TRUE)
processModelKinect = get6AxisOfFreedomVelocityModel(c(0.00,0.0,0,0,0,0), diag(c(0.5,0.4,0.2,0,0,0)), isPositionSensor = TRUE)
processModelFusion = get6degFusion(c(0,0,0,1,1,5), diag(c(1,1,1,1,0.7,0.7)))

kalmanFilterImu = kalman_init(
  processModelImu$a,
  processModelImu$P,
  processModelImu$Q,
  processModelImu$H,
  processModelImu$F,
  processModelImu$R
)

dlmImu = dlm_init(processModelImu$a,
         processModelImu$P,
         processModelImu$Q,
         processModelImu$H,
         processModelImu$F,
         processModelImu$R
)

dlmKinect = dlm_init(processModelKinect$a,
                     processModelKinect$P,
                     processModelKinect$Q,
                     processModelKinect$H,
                     processModelKinect$F,
                     processModelKinect$R
                     )

dlmFusion = dlm_init(
  processModelFusion$a,
  processModelFusion$P,
  processModelFusion$Q,
  processModelFusion$H,
  processModelFusion$F,
  processModelFusion$R
)
```

Apply the kalman filter

```{r}

dlmDataKinect = dlm::dlmFilter(
  rbind(
    interpolatedKinectValues$x[data_lower_lim:data_upper_lim],
    interpolatedKinectValues$y[data_lower_lim:data_upper_lim],
    interpolatedKinectValues$z[data_lower_lim:data_upper_lim]
  ), dlmKinect, debug = FALSE, simplify = FALSE
)

dlmDataImu = dlm::dlmFilter(
  rbind(
    imu_and_kinect$imu_acceleration.x[data_lower_lim:data_upper_lim],
    imu_and_kinect$imu_acceleration.y[data_lower_lim:data_upper_lim],
    imu_and_kinect$imu_acceleration.z[data_lower_lim:data_upper_lim]
    ), dlmImu, debug = FALSE, simplify = FALSE
  )

dlmDataFusion = dlm::dlmFilter(
  rbind(
    interpolatedKinectValues$x[data_lower_lim:data_upper_lim],
    interpolatedKinectValues$y[data_lower_lim:data_upper_lim],
    interpolatedKinectValues$z[data_lower_lim:data_upper_lim],
    imu_and_kinect$imu_acceleration.x[data_lower_lim:data_upper_lim],
    imu_and_kinect$imu_acceleration.y[data_lower_lim:data_upper_lim],
    imu_and_kinect$imu_acceleration.z[data_lower_lim:data_upper_lim]
  ), dlmFusion, debug = FALSE, simplify = FALSE
)

```

Convert the data into the accurate format
```{r}

resultDlmImu = data.frame(x=dlmDataImu[["f"]][1,], y=dlmDataImu[["f"]][2,], z=dlmDataImu[["f"]][3,])
resultDlmKinect = data.frame(x=dlmDataKinect[["f"]][1,], y=dlmDataKinect[["f"]][2,], z=dlmDataKinect[["f"]][3,])
resultDlmFusion = data.frame(
  x=dlmDataFusion[["f"]][1,],
  y=dlmDataFusion[["f"]][2,],
  z=dlmDataFusion[["f"]][3,],
  vx=dlmDataFusion[["f"]][4,],
  vy=dlmDataFusion[["f"]][5,],
  vz=dlmDataFusion[["f"]][6,]
  )

colnames(resultDlmImu) = c("v_x","v_y","v_z")
resultDlmImu = data.frame(resultDlmImu)
resultDlmImu = rbind(resultDlmImu, 0)
resultDlmImu = rbind(resultDlmImu, 0)
resultDlmImu = rbind(resultDlmImu, 0)

colnames(resultDlmKinect) = c("x","y","z")
resultDlmKinect = data.frame(resultDlmKinect)
resultDlmKinect = rbind(resultDlmKinect, 0)
resultDlmKinect = rbind(resultDlmKinect, 0)
resultDlmKinect = rbind(resultDlmKinect, 0)

colnames(resultDlmFusion) = c("x","y","z","v_x","v_y","v_z")
resultDlmFusion = data.frame(resultDlmKinect)
resultDlmFusion = rbind(resultDlmFusion, 0)
resultDlmFusion = rbind(resultDlmFusion, 0)
resultDlmFusion = rbind(resultDlmFusion, 0)

```

Plot the data


```{r}

plot_up_limit = 1600
plot_low_limit = 0



plotDf = data.frame(t = imu_and_kinect$t[1:length(imu_and_kinect$t)-1],
                    acc.x = imu_and_kinect$imu_acceleration.x[1:length(imu_and_kinect$t)-1],
                    acc.y = imu_and_kinect$imu_acceleration.y[1:length(imu_and_kinect$t)-1],
                    acc.z = imu_and_kinect$imu_acceleration.z[1:length(imu_and_kinect$t)-1],
                    kin.x = interpolatedKinectValues$x[1:length(imu_and_kinect$t)-1],
                    kin.y = interpolatedKinectValues$y[1:length(imu_and_kinect$t)-1],
                    kin.z = interpolatedKinectValues$z[1:length(imu_and_kinect$t)-1]
)

isPlottingDlmImuResults = data.frame(
  x=TRUE,
  y=TRUE,
  z=TRUE
)
isPlottingDlmKinectResults = data.frame(
  x=FALSE,
  y=FALSE,
  z=FALSE
)
isPlottingDlmFusionResults = data.frame(
  x=FALSE,
  y=FALSE,
  z=FALSE
)


if(isPlottingDlmImuResults$x) {
  # x acc plot
  accxdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_x = plotDf$acc.x[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  accxdf$K_x = as.integer(resultDlmImu$v_x[plot_low_limit:plot_up_limit])
  accxdf_long = reshape2::melt(accxdf, id = "t")
  
  
  
  ggplot(accxdf_long, aes(x=t, y=value, color=variable)) + geom_line() 
}
if(isPlottingDlmImuResults$y) {
  # y acc plot
  accydf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_y = plotDf$acc.y[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  accydf$K_y = as.integer(resultDlmImu$v_y[plot_low_limit:plot_up_limit])
  accydf_long = reshape2::melt(accydf, id = "t")
  ggplot(accydf_long, aes(x=t, y=value, color=variable)) + geom_line()
}
if(isPlottingDlmImuResults$z) {
  # z acc plot
  acczdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_z = plotDf$acc.z[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  acczdf$K_z = as.integer(resultDlmImu$v_z[plot_low_limit:plot_up_limit])
  acczdf_long = reshape2::melt(acczdf, id = "t")
  ggplot(acczdf_long, aes(x=t, y=value, color=variable)) + geom_line()  
}

if(isPlottingDlmKinectResults$x) {
  # x acc plot
  accxdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      kinect_x = plotDf$kin.x[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  accxdf$K_x = as.double(resultDlmKinect$x[plot_low_limit:plot_up_limit])
  accxdf_long = reshape2::melt(accxdf, id = "t")
  ggplot(accxdf_long, aes(x=t, y=value, color=variable)) + geom_line() 
}
if(isPlottingDlmKinectResults$y) {
  # y acc plot
  accydf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      kinect_y = plotDf$kin.y[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  accydf$K_y = as.double(resultDlmKinect$y[plot_low_limit:plot_up_limit])
  accydf_long = reshape2::melt(accydf, id = "t")
  ggplot(accydf_long, aes(x=t, y=value, color=variable)) + geom_line()
}
if(isPlottingDlmKinectResults$z) {
  # z acc plot
  acczdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      kinect_z = plotDf$kin.z[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  acczdf$K_z = as.double(resultDlmKinect$z[plot_low_limit:plot_up_limit])
  acczdf_long = reshape2::melt(acczdf, id = "t")
  ggplot(acczdf_long, aes(x=t, y=value, color=variable)) + geom_line()  
}

if(isPlottingDlmFusionResults$x) {
  # x acc plot
  accxdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_x = (plotDf$acc.x[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit] *0.0001),
                      kinect_x = plotDf$kin.x[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit] * 2)
  accxdf$K_x = as.double(resultDlmFusion$x[plot_low_limit:plot_up_limit])
  accxdf_long = reshape2::melt(accxdf, id = "t")
  ggplot(accxdf_long, aes(x=t, y=value, color=variable)) + geom_line() + ylim(-2, 2)
}
if(isPlottingDlmFusionResults$y) {
  # y acc plot
  accydf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_y = (plotDf$acc.y[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit] * 0.0001),
                      kinect_y = plotDf$kin.y[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit] * 2)
  accydf$K_y = as.double(resultDlmFusion$y[plot_low_limit:plot_up_limit])
  accydf_long = reshape2::melt(accydf, id = "t")
  ggplot(accydf_long, aes(x=t, y=value, color=variable)) + geom_line() + ylim(-2, 2)
}
if(isPlottingDlmFusionResults$z) {
  # z acc plot
  acczdf = data.frame(t = plotDf$t[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit],
                      accelerometer_z = (plotDf$acc.z[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit] * 0.00005),
                      kinect_z = plotDf$kin.z[data_lower_lim:data_upper_lim][plot_low_limit:plot_up_limit])
  acczdf$K_z = as.double(resultDlmFusion$z[plot_low_limit:plot_up_limit])
  acczdf_long = reshape2::melt(acczdf, id = "t")
  ggplot(acczdf_long, aes(x=t, y=value, color=variable)) + geom_line() 
}

```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
