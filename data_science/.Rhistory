} else {
return(list(vals[index_of_first_non_zero:(index_of_second_non_zero+1)]))
}
}
}
# Function to interpolate values inbetween
interpolateZeroesInbetween <- function(measurements){
chunks = list()
measurements_temp=measurements
for(v in 1:length(measurements)){
if(length(measurements_temp) > 1){
chunks[v] = accumulateChunks(measurements_temp)
measurements_temp = measurements_temp[2:length(measurements_temp)]
}
}
names(chunks) <- seq_along(chunks)
chunks[sapply(chunks, is.null)] <- NULL
return(unlist(mapply(interpolateDataChunk, 1:length(chunks), chunks)))
}
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
getGuanglongOrientationModel <- function(initialState, initialBelief) {
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
# Vielleicht sind die Quaternion states hier dynamisch zu sehen
processModel$Ad = matrix(data = c(
1,0,0,0,        -initialState$q1 * Ts/2  ,-initialState$q2,0     ,-initialState$q3 * Ts/2,
0,1,0,0,        initialState$q0 * Ts/2   ,initialState$q3,0      ,initialState$q2 * Ts/2,
0,0,1,0,        initialState$q3 * Ts/2   ,initialState$q0*Ts/2,0 ,-initialState$q1 * Ts/2,
0,0,0,1,        -initialState$q2 * Ts/2  ,initialState$q1*Ts/2,0 ,initialState$q0 * Ts/2,
0,0,0,0,        1,0,0,
0,0,0,0,        0,1,0,
0,0,0,0,        0,0,1
)
,nrow = 7, ncol = 7, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 7, ncol = 1) ## state vector
processModel$H = matrix(data = c(
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1
), nrow = 3, ncol = 7, byrow=TRUE) ## observation/ measurment vector
omega = matrix(data = c(
0,
0,
0,
0,
omega_x,
omega_y,
omega_z
), nrow=7,ncol=1)
processModel$Q = omega
processModel$P = initialBelief
processModel$colNames = c("q_0","q_1","q_2","q_3","v_x","v_y","v_z")
return(processModel)
}
# TODO: Transformationsmatrix berechnen
getGuanglongAccelerationModel <- function(initialState, initialBelief) {
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
processModel$Ad = matrix(data = c(
1,dt,mx_x * dt**2/2,  0,0,my_x * Ts**2/2,  0,0,mz_x * Ts**2/2,
0,1,mx_x * dt,        0,0,my_x * Ts,       0,0,mz_x *Ts,
0,0,1,                0,0,0,               0,0,0,
0,dt,mx_y * dt**2/2,  1,0,my_y * Ts**2/2,  0,0,mz_y *Ts**2/2,
0,0,mx_y * dt,        0,1,my_y * Ts,       0,0,mz_y *Ts,
0,0,0,                0,0,1,               0,0,0,
0,dt,mx_z * dt**2/2,  0,0,my_z * Ts**2/2,  1,Ts,mz_z *Ts**2/2,
0,0,mx_z *dt,         0,0,my_z * Ts,       0,1,mz_z *Ts,
0,0,0,                0,0,0,               0,0,1
)
,nrow = 9, ncol = 9, byrow=TRUE)
processModel$x = matrix(data = initialState, nrow = 9, ncol = 1) ## state vector
processModel$B = matrix(data = c(0,0,0,0,0,0,-abs(gl) * Ts**2/2, -abs(gl) * Ts, 0), nrow = 9, ncol = 1)
processModel$C = matrix(data = c(
1,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,
0,0,0,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,1
), nrow = 6, ncol = 9, byrow=TRUE) ## observation/ measurment vector
omega = matrix(data = c(
0,
0,
process_noise_acceleration_noise_omega_x,
0,
0,
process_noise_acceleration_noise_omega_y,
0,
0,
process_noise_acceleration_noise_omega_z
), nrow=9,ncol=1)
processModel$Q = processModel$Gd %*% Q %*% t(processModel$Gd)
processModel$P = initialBelief
processModel$colNames = c("x","v_x","a_x","y","v_y","a_y","z","v_z","a_z")
return(processModel)
}
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
x_initial_state_euler_vx,
x_initial_state_euler_vy,
x_initial_state_euler_vz
)
---
title: "Improving inertial Measurement data with visual sensor data from Kinect Camera"
params:
data_import_path: "D:/Projekte/Digital-Identity/data_science/imu_and_kinect_with_euler.csv"
x_initial_state_q0: 1
x_initial_state_q1: 1
x_initial_state_q2: 1
x_initial_state_q3: 1
x_initial_state_euler_vx: 1
x_initial_state_euler_vy: 1
x_initial_state_euler_vz: 1
initial_belief_00_q0: 0.05
initial_belief_11_q1: 0.05
initial_belief_22_q2: 0.05
initial_belief_33_q3: 0.05
initial_belief_44_euler_vx: 0.05
initial_belief_55_euler_vy: 0.05
initial_belief_66_euler_vz: 0.05
x_initial_state_mx_x: 1
x_initial_state_my_x: 1
x_initial_state_mz_x: 1
x_initial_state_mx_y: 1
x_initial_state_my_y: 1
x_initial_state_mz_y: 1
x_initial_state_mx_z: 1
x_initial_state_my_z: 1
x_initial_state_mz_z: 1
initial_belief_mx_x_00: 0.05
initial_belief_mx_y_11: 0.05
initial_belief_mx_z_22: 0.05
initial_belief_my_x_33: 0.05
initial_belief_my_y_44: 0.05
initial_belief_my_z_55: 0.05
initial_belief_mz_x_66: 0.05
initial_belief_mz_y_77: 0.05
initial_belief_mz_z_88: 0.05
process_noise_orientation_angular_velocity_sigma_x: 0.001
process_noise_orientation_angular_velocity_sigma_y: 0.001
process_noise_orientation_angular_velocity_sigma_z: 0.001
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = 2,
vy = 2,
vz = 2
)
params$initial_belief_22_q2
params$x_initial_state_euler_vx
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_q0,
q1 = params$x_initial_q1,
q2 = params$x_initial_q2,
q3 = params$x_initial_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_state = data.frame(
q0 = params$x_initial_state_q0,
q1 = params$x_initial_state_q1,
q2 = params$x_initial_state_q2,
q3 = params$x_initial_state_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_belief = diag(
c(params$initial_belief_00_q0,  params$initial_belief_11_q1,  params$initial_belief_22_q2,  params$initial_belief_33_q3,
params$initial_belief_44_euler_vx,  params$initial_belief_55_euler_vy, params$initial_belief_66_euler_vz
)
)
#
processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief)
data.frame(a = c(1,2,3))
data.frame(a = c(1,2,3))[,]
data.frame(a = c(1,2,3))[1,]
data.frame(a = c(1,2,3))[,1]
matrix(data = data.frame(a = c(1,2,3))[,1], nrow = 3, ncol = 1)
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
getGuanglongOrientationModel <- function(initialState, initialBelief) {
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
# Vielleicht sind die Quaternion states hier dynamisch zu sehen
processModel$Ad = matrix(data = c(
1,0,0,0,        -initialState$q1 * Ts/2  ,-initialState$q2,0     ,-initialState$q3 * Ts/2,
0,1,0,0,        initialState$q0 * Ts/2   ,initialState$q3,0      ,initialState$q2 * Ts/2,
0,0,1,0,        initialState$q3 * Ts/2   ,initialState$q0*Ts/2,0 ,-initialState$q1 * Ts/2,
0,0,0,1,        -initialState$q2 * Ts/2  ,initialState$q1*Ts/2,0 ,initialState$q0 * Ts/2,
0,0,0,0,        1,0,0,
0,0,0,0,        0,1,0,
0,0,0,0,        0,0,1
)
,nrow = 7, ncol = 7, byrow=TRUE)
processModel$x = matrix(data = initialState[,1], nrow = 7, ncol = 1) ## state vector
processModel$H = matrix(data = c(
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1
), nrow = 3, ncol = 7, byrow=TRUE) ## observation/ measurment vector
omega = matrix(data = c(
0,
0,
0,
0,
params$process_noise_orientation_angular_velocity_sigma_x,
params$process_noise_orientation_angular_velocity_sigma_y,
params$process_noise_orientation_angular_velocity_sigma_z
), nrow=7,ncol=1)
processModel$Q = omega
processModel$P = initialBelief
processModel$colNames = c("q_0","q_1","q_2","q_3","v_x","v_y","v_z")
return(processModel)
}
#
processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief)
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$Ad, R = processModel$R)
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
getGuanglongOrientationModel <- function(initialState, initialBelief) {
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
# Vielleicht sind die Quaternion states hier dynamisch zu sehen
processModel$Ad = matrix(data = c(
1,0,0,0,        -initialState$q1 * Ts/2  ,-initialState$q2     ,-initialState$q3 * Ts/2,
0,1,0,0,        initialState$q0 * Ts/2   ,initialState$q3      ,initialState$q2 * Ts/2,
0,0,1,0,        initialState$q3 * Ts/2   ,initialState$q0*Ts/2 ,-initialState$q1 * Ts/2,
0,0,0,1,        -initialState$q2 * Ts/2  ,initialState$q1*Ts/2 ,initialState$q0 * Ts/2,
0,0,0,0,        1,0,0,
0,0,0,0,        0,1,0,
0,0,0,0,        0,0,1
)
,nrow = 7, ncol = 7, byrow=TRUE)
processModel$x = matrix(data = initialState[,1], nrow = 7, ncol = 1) ## state vector
processModel$H = matrix(data = c(
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1
), nrow = 3, ncol = 7, byrow=TRUE) ## observation/ measurment vector
omega = matrix(data = c(
0,
0,
0,
0,
params$process_noise_orientation_angular_velocity_sigma_x,
params$process_noise_orientation_angular_velocity_sigma_y,
params$process_noise_orientation_angular_velocity_sigma_z
), nrow=7,ncol=1)
processModel$Q = omega
processModel$P = initialBelief
processModel$colNames = c("q_0","q_1","q_2","q_3","v_x","v_y","v_z")
return(processModel)
}
#
processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief)
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$Ad, R = processModel$R)
View(processOrientationModel)
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
getGuanglongOrientationModel <- function(initialState, initialBelief) {
#Currently used variable names -> variable names from Slides
# F -> A: State Transition Matrix
# a -> x: State Vector
# H -> C: Observation Matrix
# Q -> Q: Process Noise Matrix
# R -> R: Sensor Noise Matrix
# P -> P: Sensor Belief
processModel = list()
Ts = 0.014
# Vielleicht sind die Quaternion states hier dynamisch zu sehen
processModel$Ad = matrix(data = c(
1,0,0,0,        -initialState$q1 * Ts/2  ,-initialState$q2     ,-initialState$q3 * Ts/2,
0,1,0,0,        initialState$q0 * Ts/2   ,initialState$q3      ,initialState$q2 * Ts/2,
0,0,1,0,        initialState$q3 * Ts/2   ,initialState$q0*Ts/2 ,-initialState$q1 * Ts/2,
0,0,0,1,        -initialState$q2 * Ts/2  ,initialState$q1*Ts/2 ,initialState$q0 * Ts/2,
0,0,0,0,        1,0,0,
0,0,0,0,        0,1,0,
0,0,0,0,        0,0,1
)
,nrow = 7, ncol = 7, byrow=TRUE)
processModel$x = matrix(data = initialState[,1], nrow = 7, ncol = 1) ## state vector
processModel$H = matrix(data = c(
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1
), nrow = 3, ncol = 7, byrow=TRUE) ## observation/ measurment vector
omega = c(
0,
0,
0,
0,
params$process_noise_orientation_angular_velocity_sigma_x,
params$process_noise_orientation_angular_velocity_sigma_y,
params$process_noise_orientation_angular_velocity_sigma_z
)
processModel$Q = diag(omega)
processModel$P = initialBelief
processModel$colNames = c("q_0","q_1","q_2","q_3","v_x","v_y","v_z")
return(processModel)
}
initial_orientation_state = data.frame(
q0 = params$x_initial_state_q0,
q1 = params$x_initial_state_q1,
q2 = params$x_initial_state_q2,
q3 = params$x_initial_state_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_belief = diag(
c(params$initial_belief_00_q0,  params$initial_belief_11_q1,  params$initial_belief_22_q2,  params$initial_belief_33_q3,
params$initial_belief_44_euler_vx,  params$initial_belief_55_euler_vy, params$initial_belief_66_euler_vz
)
)
#
processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief)
dlmFusionModel = dlm_init(x = processModel$x, P = processModel$P, Q = processModel$Q, C = processModel$C, A = processModel$Ad, R = processModel$R)
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$C,
A = processOrientationModel$Ad,
R = processOrientationModel$R)
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$H,
A = processOrientationModel$Ad,
R = processOrientationModel$R)
identity(7)
identity(x = 0)
matrix(nrow = 7, ncol = 7)
matrix(nrow = 7, ncol = 7, data = 0)
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$H,
A = processOrientationModel$Ad,
R = matrix(nrow = 7, ncol = 7, data = 0))
diag(nrow = 7, ncol = 7)
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$H,
A = processOrientationModel$Ad,
R = diag(nrow = 7, ncol = 7))
View(processOrientationModel)
processOrientationModel[["Ad"]]
processOrientationModel[["Q"]]
processOrientationModel[["H"]]
processOrientationModel[["x"]]
processOrientationModel[["P"]]
processOrientationModel[["x"]]
processOrientationModel[["P"]]
processOrientationModel[["Q"]]
processOrientationModel[["H"]]
processOrientationModel[["Ad"]]
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$H,
A = processOrientationModel$Ad,
R = diag(nrow = 7, ncol = 7))
initial_orientation_state = data.frame(
q0 = params$x_initial_state_q0,
q1 = params$x_initial_state_q1,
q2 = params$x_initial_state_q2,
q3 = params$x_initial_state_q3,
vx = params$x_initial_state_euler_vx,
vy = params$x_initial_state_euler_vy,
vz = params$x_initial_state_euler_vz
)
initial_orientation_belief = diag(
c(params$initial_belief_00_q0,  params$initial_belief_11_q1,  params$initial_belief_22_q2,  params$initial_belief_33_q3,
params$initial_belief_44_euler_vx,  params$initial_belief_55_euler_vy, params$initial_belief_66_euler_vz
)
)
#
processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief)
processAccelerationModel = getGuanglongAccelerationModel(initial_acceleration_state, initial_acceleration_belief)
dlmFusionModel = dlm_init(x = processOrientationModel$x,
P = processOrientationModel$P,
Q = processOrientationModel$Q,
C = processOrientationModel$H,
A = processOrientationModel$Ad,
R = diag(nrow = 7, ncol = 7))
dlmFusionModel = dlm::dlm(FF = processOrientationModel$H,
V = diag(nrow = 7, ncol = 7),
GG = processOrientationModel$Ad,
W = processOrientationModel$Q,
m0 = processOrientationModel$x,
C0 = processOrientationModel$P)
dlmFusionModel = dlm::dlm(FF = processModelImu$H,
V = processModelImu$R,
GG = processModelImu$Ad,
W = processModelImu$Q,
m0 = processModelImu$x,
C0 = processModelImu$P)
dlmFusionModel = dlm::dlm(FF = processModelImu$H,
V = processModelImu$R,
GG = processModelImu$F,
W = processModelImu$Q,
m0 = processModelImu$x,
C0 = processModelImu$P)
dlmFusionModel = dlm::dlm(FF = processModelImu$H,
V = processModelImu$R,
GG = processModelImu$F,
W = processModelImu$Q,
m0 = processModelImu$a,
C0 = processModelImu$P)
