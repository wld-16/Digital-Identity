max(simulationAccelerationMeasurementsAsMatrix[4,], simulatedfkfGuanglongAccelerationModel$att[6,1:simulatedMax]) + plot_limit_offset))
polygon(
x = c(sim_time, rev(sim_time)),
y = c(simulatedfkfGuanglongAccelerationModel$Ptt[6,6,1:simulatedMax] + simulatedfkfGuanglongAccelerationModel$att[6,1:simulatedMax], rev(simulatedfkfGuanglongAccelerationModel$att[6,1:simulatedMax] - simulatedfkfGuanglongAccelerationModel$Ptt[6,6,1:simulatedMax] )),
col = "lightsteelblue",
border = NA)
lines(simulatedfkfGuanglongAccelerationModel$at[6,1:simulatedMax] ~ sim_time, col = "blue")
lines(simulationAccelerationMeasurementsAsMatrix[4,] ~ sim_time)
legend("bottomright", legend = c("a_y state", "simulated ay", "process uncertainty"), lwd = 3, col = c("blue", "black", "lightsteelblue"))
plot(simulationAccelerationMeasurementsAsMatrix[5,] ~ sim_time, pch  = 20, main = "p_z in simulation", ylab = "p_z",xlab="time in seconds", type='l', ylim=c(
min(simulationAccelerationMeasurementsAsMatrix[5,], simulatedfkfGuanglongAccelerationModel$att[7,1:simulatedMax]) - plot_limit_offset,
max(simulationAccelerationMeasurementsAsMatrix[5,], simulatedfkfGuanglongAccelerationModel$att[7,1:simulatedMax]) + plot_limit_offset))
polygon(
x = c(sim_time, rev(sim_time)),
y = c(simulatedfkfGuanglongAccelerationModel$Ptt[7,7,1:simulatedMax] + simulatedfkfGuanglongAccelerationModel$att[7,1:simulatedMax], rev(simulatedfkfGuanglongAccelerationModel$att[7,1:simulatedMax] - simulatedfkfGuanglongAccelerationModel$Ptt[7,7,1:simulatedMax] )),
col = "lightsteelblue",
border = NA)
lines(simulatedfkfGuanglongAccelerationModel$att[7,1:simulatedMax] ~ sim_time, col = "blue")
lines(simulationAccelerationMeasurementsAsMatrix[5,] ~ sim_time)
legend("bottomright", legend = c("p_z state", "simulated pz", "process uncertainty"), lwd = 3, col = c("blue", "black", "lightsteelblue"))
plot(simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax] ~ sim_time, pch  = 20, main = "v_z in simulation", ylab = "v_z",xlab="time in seconds", type='l', ylim=c(
min(simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax]) - plot_limit_offset,
max(simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax]) + plot_limit_offset))
polygon(
x = c(sim_time, rev(sim_time)),
y = c(simulatedfkfGuanglongAccelerationModel$Ptt[8,8,1:simulatedMax] + simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax], rev(simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax] - simulatedfkfGuanglongAccelerationModel$Ptt[8,8,1:simulatedMax] )),
col = "lightsteelblue",
border = NA)
lines(simulatedfkfGuanglongAccelerationModel$att[8,1:simulatedMax] ~ sim_time, col = "blue")
legend("bottomright", legend = c("v_z state", "process uncertainty"), lwd = 3, col = c("blue", "lightsteelblue"))
plot(simulationAccelerationMeasurementsAsMatrix[6,] ~ sim_time, pch  = 20, main = "a_z in simulation", ylab = "a_z",xlab="time in seconds", type='l', ylim=c(
min(simulationAccelerationMeasurementsAsMatrix[6,], simulatedfkfGuanglongAccelerationModel$att[9,1:simulatedMax]) - plot_limit_offset,
max(simulationAccelerationMeasurementsAsMatrix[6,], simulatedfkfGuanglongAccelerationModel$att[9,1:simulatedMax]) + plot_limit_offset))
polygon(
x = c(sim_time, rev(sim_time)),
y = c(simulatedfkfGuanglongAccelerationModel$Ptt[9,9,1:simulatedMax] + simulatedfkfGuanglongAccelerationModel$att[9,1:simulatedMax], rev(simulatedfkfGuanglongAccelerationModel$att[9,1:simulatedMax] - simulatedfkfGuanglongAccelerationModel$Ptt[9,9,1:simulatedMax] )),
col = "lightsteelblue",
border = NA)
lines(simulatedfkfGuanglongAccelerationModel$att[9,1:simulatedMax] ~ sim_time, col = "blue")
lines(simulationAccelerationMeasurementsAsMatrix[6,] ~ sim_time)
legend("bottomright", legend = c("a_z state", "simulated az", "process uncertainty"), lwd = 3, col = c("blue", "black", "lightsteelblue"))
plot(simulatedfkfGuanglongAccelerationModel, type = "resid.qq")
knit_with_parameters("D:/Projekte/Digital-Identity/data_science/workbooks/notebook_guanglong_simulation.Rmd", encoding = "UTF-8")
# Load Libraries
library(shiny)
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
print(params)
#Execute this line of code to load all the functions
source(paste(params$base_import_path, "/scripts/functions.R",sep=""))
Ts = params$T_s
simulatedMax = params$sample_size
# Here is the definition of the state space models
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
# TODO: Transformationsmatrix berechnen für acceleration modell ?
source(paste(params$base_import_path, "/scripts/models.R",sep=""))
# Init the state space models
initial_orientation_state = c(
params$x_initial_state_q0,
params$x_initial_state_q1,
params$x_initial_state_q2,
params$x_initial_state_q3,
params$x_initial_state_euler_vx,
params$x_initial_state_euler_vy,
params$x_initial_state_euler_vz
)
initial_orientation_belief = diag(
c(
params$initial_belief_00_q0,
params$initial_belief_11_q1,
params$initial_belief_22_q2,
params$initial_belief_33_q3,
params$initial_belief_44_euler_vx,
params$initial_belief_55_euler_vy,
params$initial_belief_66_euler_vz
)
)
orientation_process_noise = data.frame(
vx = params$process_noise_orientation_angular_velocity_sigma_x,
vy = params$process_noise_orientation_angular_velocity_sigma_y,
vz = params$process_noise_orientation_angular_velocity_sigma_z
)
orientation_sensor_noise = data.frame(
vx = params$sensor_noise_imu_euler_velocity_x,
vy = params$sensor_noise_imu_euler_velocity_y,
vz = params$sensor_noise_imu_euler_velocity_z
)
#
processOrientationModel = getGuanglongOrientationModel(Ts, initial_orientation_state, initial_orientation_belief, orientation_process_noise, orientation_sensor_noise)
# Load Libraries
library(shiny)
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
print(params)
#Execute this line of code to load all the functions
source(paste(params$base_import_path, "/scripts/functions.R",sep=""))
Ts = params$T_s
simulatedMax = params$sample_size
# Here is the definition of the state space models
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
# TODO: Transformationsmatrix berechnen für acceleration modell ?
source(paste(params$base_import_path, "/scripts/models.R",sep=""))
# Init the state space models
initial_orientation_state = c(
params$x_initial_state_q0,
params$x_initial_state_q1,
params$x_initial_state_q2,
params$x_initial_state_q3,
params$x_initial_state_euler_vx,
params$x_initial_state_euler_vy,
params$x_initial_state_euler_vz
)
initial_orientation_belief = diag(
c(
params$initial_belief_00_q0,
params$initial_belief_11_q1,
params$initial_belief_22_q2,
params$initial_belief_33_q3,
params$initial_belief_44_euler_vx,
params$initial_belief_55_euler_vy,
params$initial_belief_66_euler_vz
)
)
orientation_process_noise = data.frame(
vx = params$process_noise_orientation_angular_velocity_sigma_x,
vy = params$process_noise_orientation_angular_velocity_sigma_y,
vz = params$process_noise_orientation_angular_velocity_sigma_z
)
orientation_sensor_noise = data.frame(
vx = params$sensor_noise_imu_euler_velocity_x,
vy = params$sensor_noise_imu_euler_velocity_y,
vz = params$sensor_noise_imu_euler_velocity_z
)
#
processOrientationModel = getGuanglongOrientationModel(Ts, initial_orientation_state, initial_orientation_belief, orientation_process_noise, orientation_sensor_noise)
#simulation_rotation_quaternion = data.frame(
#  w = array(data = 1/sqrt(2), dim = simulatedMax),
#  x = array(data = 0, dim = simulatedMax),
#  y = array(data = 1/sqrt(2), dim = simulatedMax),
#  z = array(data = 0, dim = simulatedMax)
#)
simulation_rotation_quaternion = data.frame(
w = array(data = 1, dim = simulatedMax),
x = array(data = 0, dim = simulatedMax),
y = array(data = 0, dim = simulatedMax),
z = array(data = 0, dim = simulatedMax)
)
## only for simulation
rotationMatrix = quaternion_rotation_matrix(
simulation_rotation_quaternion$w[1],
simulation_rotation_quaternion$x[1],
simulation_rotation_quaternion$y[1],
simulation_rotation_quaternion$z[1]
)
##
#rotationMatrix = quaternion_rotation_matrix(1,0,0,0)
initial_matrixHandToLocal = data.frame(
mx_x = rotationMatrix[1,1], my_x = rotationMatrix[1,2], mz_x = rotationMatrix[1,3],
mx_y = rotationMatrix[2,1], my_y = rotationMatrix[2,2], mz_y = rotationMatrix[2,3],
mx_z = rotationMatrix[3,1], my_z = rotationMatrix[3,2], mz_z = rotationMatrix[3,3]
)
## only for simulation
initial_gravity = data.frame(
x = 0,
y = 0,
z = 9.81
)
##
initial_acceleration_state = c(
params$x_initial_state_px,
params$x_initial_state_vx,
params$x_initial_state_ax,
params$x_initial_state_py,
params$x_initial_state_vy,
params$x_initial_state_ay,
params$x_initial_state_pz,
params$x_initial_state_vz,
params$x_initial_state_az
)
initial_acceleration_belief = diag(c(
params$initial_belief_px_00,
params$initial_belief_vx_11,
params$initial_belief_ax_22,
params$initial_belief_py_33,
params$initial_belief_vy_44,
params$initial_belief_ay_55,
params$initial_belief_pz_66,
params$initial_belief_vz_77,
params$initial_belief_az_88
))
acceleration_process_noise = data.frame(
x = params$process_noise_acceleration_noise_omega_x,
y = params$process_noise_acceleration_noise_omega_y,
z = params$process_noise_acceleration_noise_omega_z
)
acceleration_sensor_noise = data.frame(
x = params$sensor_noise_kinect_sigma_x,
y = params$sensor_noise_kinect_sigma_y,
z = params$sensor_noise_kinect_sigma_z,
ax = params$sensor_noise_imu_sigma_x,
ay = params$sensor_noise_imu_sigma_y,
az = params$sensor_noise_imu_sigma_z
)
processAccelerationModel = getGuanglongAccelerationModel(Ts, initial_acceleration_state, initial_acceleration_belief, initial_matrixHandToLocal, initial_gravity, acceleration_process_noise, acceleration_sensor_noise)
# The following chunk generates data from an simulator for orientation
# Simulation of orientation
orientation_process_noise = data.frame(
vx = params$process_noise_orientation_angular_velocity_sigma_x,
vy = params$process_noise_orientation_angular_velocity_sigma_y,
vz = params$process_noise_orientation_angular_velocity_sigma_z
)
simulation_orientation_process_noise = data.frame(
vx = 0.05,
vy = 0.05,
vz = 0.05
)
simulation_orientation_sensor_noise = data.frame(
vx = 0.01,
vy = 0.01,
vz = 0.01
)
simulation_acceleration_process_noise = data.frame(
x = 0.05,
y = 0.00,
z = 0.00
)
simulation_acceleration_sensor_noise = data.frame(
x = 0.01,
y = 0.00,
z = 0.01,
ax = 0.01,
ay = 0.01,
az = 0.00
)
source(paste(params$base_import_path, "/scripts/simulation.R",sep=""))
# Simulation Data for Orientation
setOrientationSimulationModell(processOrientationModel)
setOrientationSimulationProcessNoise(simulation_orientation_process_noise)
setOrientationSimulationSensorNoise(simulation_orientation_sensor_noise)
x_k = as.double(initial_orientation_state)
simulationOrientationData = Reduce(x = lapply(1:simulatedMax, justReturn, x_k), f=generateNextOrientationFrame, accumulate = TRUE)
simulationOrientationMeasurements = lapply(simulationOrientationData, generateNextOrientationMeasurement)
simulatedOrientationDataAsMatrix = matrix(data = unlist(simulationOrientationData), nrow = 7, ncol=simulatedMax)
simulationOrientationMeasurementsAsMatrix = matrix(data = unlist(simulationOrientationMeasurements), nrow = 3, ncol=simulatedMax)
simulated_normalized_quaternions = matrix(data = c(simulatedOrientationDataAsMatrix[1,], simulatedOrientationDataAsMatrix[2,], simulatedOrientationDataAsMatrix[3,], simulatedOrientationDataAsMatrix[4,]), nrow = simulatedMax, ncol=4)
# Simulation Data for Position
setAccelerationSimulationModell(processAccelerationModel)
setAccelerationSimulationProcessNoise(simulation_acceleration_process_noise)
setAccelerationSimulationSensorNoise(simulation_acceleration_sensor_noise)
x_k = as.double(initial_acceleration_state)
# With gravity
simulationAccelerationData = Reduce(x = lapply(1:simulatedMax, justReturn,x_k), f=generateNextAccelerationFrameWithGravity, accumulate = TRUE)
simulationAccelerationData = lapply(simulationAccelerationData, function(data) data + c(0,0,0,0,0,0,0,0,-9.81))
# without gravity
#simulationAccelerationData = Reduce(x = lapply(1:simulatedMax, justReturn,x_k), f=generateNextAccelerationFrame, accumulate = TRUE)
simulationAccelerationMeasurements = lapply(simulationAccelerationData, generateNextAccelerationMeasurement)
simulatedDataAccAsMatrix = matrix(data = unlist(simulationAccelerationData), nrow = 9, ncol=simulatedMax)
simulationAccelerationMeasurementsAsMatrix = matrix(data = unlist(simulationAccelerationMeasurements), nrow = 6, ncol=simulatedMax)
simulatedfkfGuanglongOrientationModel = fkf(
a0 = processOrientationModel$x[,1],
P0 = processOrientationModel$P,
dt = matrix(data = 0, nrow = 7, ncol = 1),
ct = matrix(data = 0, nrow = 3, ncol = 1),
GGt = diag(nrow = 3, ncol = 3),
Zt = processOrientationModel$H,
Tt = array(as.numeric(unlist(lapply(1:simulatedMax,simulated_orientation_transition_at_index))), dim=c(7, 7, simulatedMax)),
HHt = processOrientationModel$Q,
yt = matrix(data = c(
simulationOrientationMeasurementsAsMatrix[1,],
simulationOrientationMeasurementsAsMatrix[2,],
simulationOrientationMeasurementsAsMatrix[3,]
), nrow = 3, ncol = simulatedMax, byrow = TRUE)
)
simulatedfkfGuanglongAccelerationModel = fkf(
a0 = processAccelerationModel$x[,1],
P0  = processAccelerationModel$P,
dt = processAccelerationModel$B,
ct = matrix(data = 0, nrow = 6, ncol = 1),
GGt = diag(x= c(1,1,1,1,1,1)),
Zt = processAccelerationModel$H,
Tt = array(as.numeric(unlist(lapply(1:simulatedMax,acceleration_simulation_transition_at_index))), dim=c(9, 9, simulatedMax)),
HHt = processAccelerationModel$Q,
yt = matrix(data = c(
simulationAccelerationMeasurementsAsMatrix[1,],
simulationAccelerationMeasurementsAsMatrix[2,],
simulationAccelerationMeasurementsAsMatrix[3,],
simulationAccelerationMeasurementsAsMatrix[4,],
simulationAccelerationMeasurementsAsMatrix[5,],
simulationAccelerationMeasurementsAsMatrix[6,]
), nrow = 6, ncol = simulatedMax, byrow = TRUE)
)
sim_time = c(1:simulatedMax)
sim_time = sim_time * Ts
# Plot the orientation
plot_limit_offset = 0.5
plot(simulatedfkfGuanglongOrientationModel$att[1,1:simulatedMax] ~ sim_time, pch  = 20, main = "q_w state", ylab = "value normalized", xlab="time in seconds", type='l', ylim=c(
min(simulatedfkfGuanglongOrientationModel$att[1,1:simulatedMax]) - plot_limit_offset,
max(simulatedfkfGuanglongOrientationModel$att[1,1:simulatedMax]) + plot_limit_offset))
print(params)
print(params)
---
title: "Notebook Simulation Guanglong Model"
params:
base_import_path:
value: "D:/Projekte/Digital-Identity/data_science/"
T_s:
value: 0.014
input: numeric
sample_size:
value: 300
input: numeric
x_initial_state_q0:
value: 1.01
input: numeric
x_initial_state_q1:
value: 0.01
input: numeric
x_initial_state_q2:
value: 0.01
input: numeric
x_initial_state_q3:
value: 0.01
input: numeric
x_initial_state_euler_vx:
value: 1.01
input: numeric
x_initial_state_euler_vy:
value: 0.01
input: numeric
x_initial_state_euler_vz:
value: 0.01
input: numeric
initial_belief_00_q0:
value: 0.05
input: numeric
initial_belief_11_q1:
value: 0.05
input: numeric
initial_belief_22_q2:
value: 0.05
input: numeric
initial_belief_33_q3:
value: 0.05
input: numeric
initial_belief_44_euler_vx:
value: 2.1
input: numeric
initial_belief_55_euler_vy:
value: 2.1
input: numeric
initial_belief_66_euler_vz:
value: 2.1
input: numeric
process_noise_orientation_angular_velocity_sigma_x:
value: 0.05
input: numeric
process_noise_orientation_angular_velocity_sigma_y:
value: 0.05
input: numeric
process_noise_orientation_angular_velocity_sigma_z:
value: 0.05
input: numeric
sensor_noise_imu_euler_velocity_x:
value: 0.01
input: numeric
sensor_noise_imu_euler_velocity_y:
value: 0.01
input: numeric
sensor_noise_imu_euler_velocity_z:
value: 0.01
input: numeric
x_initial_state_px:
value: 0.00001
input: numeric
x_initial_state_vx:
value: 0.00001
input: numeric
x_initial_state_ax:
value: 0.00001
input: numeric
x_initial_state_py:
value: 0.00001
input: numeric
x_initial_state_vy:
value: 0.00001
input: numeric
x_initial_state_ay:
value: 0.0001
input: numeric
x_initial_state_pz:
value: 10.00001
input: numeric
x_initial_state_vz:
value: 0.00001
input: numeric
x_initial_state_az:
value: 9.81
input: numeric
initial_belief_px_00:
value: 0.01
input: numeric
initial_belief_vx_11:
value: 0.01
input: numeric
initial_belief_ax_22:
value: 0.01
input: numeric
initial_belief_py_33:
value: 10.01
input: numeric
initial_belief_vy_44:
value: 0.01
input: numeric
initial_belief_ay_55:
value: 0.01
input: numeric
initial_belief_pz_66:
value: 0.01
input: numeric
initial_belief_vz_77:
value: 0.01
input: numeric
initial_belief_az_88:
value: 0.01
input: numeric
process_noise_acceleration_noise_omega_x:
value: 0.02
input: numeric
process_noise_acceleration_noise_omega_y:
value: 0.02
input: numeric
process_noise_acceleration_noise_omega_z:
value: 0.02
input: numeric
sensor_noise_kinect_sigma_x:
value: 0.01
input: numeric
sensor_noise_kinect_sigma_y:
value: 0.01
input: numeric
sensor_noise_kinect_sigma_z:
value: 0.01
input: numeric
sensor_noise_imu_sigma_x:
value: 0.01
input: numeric
sensor_noise_imu_sigma_y:
value: 0.01
input: numeric
sensor_noise_imu_sigma_z:
value: 0.01
input: numeric
---
knit_with_parameters("D:/Projekte/Digital-Identity/data_science/workbooks/notebook_guanglong_simulation.Rmd", encoding = "UTF-8")
library(shiny)
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
library(shiny)
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
```{r}
print(params)
# Install Libraries, when necessary
#install.packages("RMThreshold")
#install.packages("jsonlite")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("patchwork")
#install.packages("reshape2")
#install.packages("RSpincalc")
#install.packages("LaplacesDemon")
#install.packages('Rcpp')
#install.packages('KFK')
#install.packages("shiny")
# Load Libraries
library(shiny)
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
print(params)
print(params)
