---
title: "Improving inertial Measurement data with visual sensor data from Kinect Camera"
params: 
  base_import_path:
    value: "D:/Projekte/Digital-Identity/data_science/"
  data_import_path:
    value: "res/imu_and_kinect_with_eule7r.csv"
    input: file
  T_s:
    value: 0.014
    input: numeric
  x_initial_state_q0:
    value: 1.0
    input: numeric
  x_initial_state_q1:
    value: 0.0
    input: numeric
  x_initial_state_q2:
    value: 0.0
    input: numeric
  x_initial_state_q3:
    value: 0.0
    input: numeric
  x_initial_state_euler_vx:
    value: 1.0
    input: numeric
  x_initial_state_euler_vy:
    value: 0.2
    input: numeric
  x_initial_state_euler_vz:
    value: 0.0
    input: numeric
  initial_belief_00_q0:
    value: 0.5
    input: numeric
  initial_belief_11_q1:
    value: 0.5
    input: numeric
  initial_belief_22_q2:
    value: 0.5
    input: numeric
  initial_belief_33_q3:
    value: 0.5
    input: numeric
  initial_belief_44_euler_vx:
    value: 0.5
    input: numeric
  initial_belief_55_euler_vy:
    value: 0.0
    input: numeric
  initial_belief_66_euler_vz:
    value: 0.0
    input: numeric
  x_initial_state_px:
    value: 0.0
    input: numeric
  x_initial_state_vx:
    value: 0.0
    input: numeric
  x_initial_state_ax:
    value: 0.0
    input: numeric
  x_initial_state_py:
    value: 0.0
    input: numeric
  x_initial_state_vy:
    value: 0.0
    input: numeric
  x_initial_state_ay:
    value: 0.0
    input: numeric
  x_initial_state_pz:
    value: 0.0
    input: numeric
  x_initial_state_vz:
    value: 0.0
    input: numeric
  x_initial_state_az:
    value: 1.0
    input: numeric
  initial_belief_px_00:
    value: 0.05
    input: numeric
  initial_belief_vx_11:
    value: 0.05
    input: numeric
  initial_belief_ax_22:
    value: 0.05
    input: numeric
  initial_belief_py_33:
    value: 0.05
    input: numeric
  initial_belief_vy_44:
    value: 0.05
    input: numeric
  initial_belief_ay_55:
    value: 0.05
    input: numeric
  initial_belief_pz_66:
    value: 0.05
    input: numeric
  initial_belief_vz_77:
    value: 0.05
    input: numeric
  initial_belief_az_88:
    value: 0.05
    input: numeric
  process_noise_orientation_angular_velocity_sigma_x:
    value: 0.05
    input: numeric
  process_noise_orientation_angular_velocity_sigma_y:
    value: 0.05
    input: numeric
  process_noise_orientation_angular_velocity_sigma_z:
    value: 0.05
    input: numeric
  process_noise_acceleration_noise_omega_x:
    value: 0.05
    input: numeric
  process_noise_acceleration_noise_omega_y:
    value: 0.05
    input: numeric
  process_noise_acceleration_noise_omega_z:
    value: 0.05
    input: numeric
  sensor_noise_imu_euler_velocity_x:
    value:  0.5
    input: numeric
  sensor_noise_imu_euler_velocity_y:
    value:  0.5
    input: numeric
  sensor_noise_imu_euler_velocity_z:
    value:  0.5
    input: numeric
  sensor_noise_imu_sigma_x:
    value: 0.009810001
    input: numeric
  sensor_noise_imu_sigma_y:
    value: 0.009810001
    input: numeric
  sensor_noise_imu_sigma_z:
    value: 0.009810001
    input: numeric
  sensor_noise_kinect_sigma_x:
    value: 0.05
    input: numeric
  sensor_noise_kinect_sigma_y:
    value: 0.05
    input: numeric
  sensor_noise_kinect_sigma_z:
    value: 0.05
    input: numeric
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Execute this chunk to load install the required libraries

```{r}
#install.packages("RMThreshold")
#install.packages("jsonlite")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("patchwork")
#install.packages("reshape2")
#install.packages("RSpincalc")
#install.packages("LaplacesDemon")
#install.packages('Rcpp')
#install.packages('KFK')
#install.packages("shiny")
```


Execute this chunk of code to load all the libraries

```{r}
library(dplyr)
library(RMThreshold)
library(ggplot2)
library(RSpincalc)
library(reshape2)
library(LaplacesDemon)
library(Rcpp)
library(FKF)
library(shiny)
```

Execute this line of code to load all the functions



```{r}

source(paste(params$base_import_path, "/scripts/functions.R",sep=""))

Ts = params$T_s

```

Here is the definition of the state space models

```{r}
# Will need euler angle velocity sensor
# TODO: Quaternions need to be normalized
# TODO: Transformationsmatrix berechnen für acceleration modell ?
source(paste(params$base_import_path, "/scripts/models.R",sep=""))
```



To load the data from the sensors execute this snippet of code 

```{r}
imkDfRaw <- read.csv2(paste(params$base_import_path, params$data_import_path, sep=""))
```


Here are some operations on the raw kinect data, to interpolate values
```{r}

# Zeit in Millisekunden ?bersetzen

imkDfRaw$t = (imkDfRaw$t.m * 60 * 1000 + imkDfRaw$t.s * 1000 + imkDfRaw$t.ms)

# Erstelle Data Frame f?r kinect daten
# Darauf achten das datens?tze gleiche L?nge aufweisen

imkDf = imkDfRaw[abs(imkDfRaw$kinect_foot_right.x) > 0,]

uXP = crossProduct(imkDf$kinect_hand_right_orientation.x, imkDf$kinect_hand_right_orientation.x, imkDf$kinect_hand_right_orientation.x, imkDf$imu_acceleration.x, imkDf$imu_acceleration.y, imkDf$imu_acceleration.z)


rightSide_qp = imkDf$kinect_hand_left_orientation.w * c(imkDf$imu_acceleration.x, imkDf$imu_acceleration.y, imkDf$imu_acceleration.z) + uXP

qp = data.frame(w = scalarProduct(
  -imkDf$kinect_hand_right_orientation.x,
  -imkDf$kinect_hand_right_orientation.y, 
  -imkDf$kinect_hand_right_orientation.z,
  imkDf$imu_acceleration.x,
  imkDf$imu_acceleration.y,
  imkDf$imu_acceleration.z
  ),x = rightSide_qp$x,y = rightSide_qp$y,z = rightSide_qp$z)

uXP = crossProduct(qp$x,qp$y,qp$z,
                   imkDf$kinect_hand_right_orientation.x,
                   imkDf$kinect_hand_right_orientation.y,
                   imkDf$kinect_hand_right_orientation.z)

rightSide_qp_q = qp$w * c( 
  -imkDf$kinect_hand_right_orientation.x,
  -imkDf$kinect_hand_right_orientation.y, 
  -imkDf$kinect_hand_right_orientation.z) + uXP

# Ist das Skalarprodukt hier überhaupt notwendig??
qp_q = data.frame(w = scalarProduct(
  -qp$x,
  -qp$y,
  -qp$z,
  -imkDf$kinect_hand_right_orientation.x,
  -imkDf$kinect_hand_right_orientation.y, 
  -imkDf$kinect_hand_right_orientation.z
), x = rightSide_qp_q$x, y = rightSide_qp_q$y, z = rightSide_qp_q$z)

rotatedValues = data.frame(x = rightSide_qp_q$x, y = rightSide_qp_q$y, z = rightSide_qp_q$z)

#imkDf$rotated_x_acceleration = rightSide_qp_q$x
#imkDf$rotated_y_acceleration = rightSide_qp_q$y
#imkDf$rotated_z_acceleration = rightSide_qp_q$z

imkDf$rotated_x_acceleration = as.numeric(unlist(lapply(1:length(imkDf$t.m),rotated_X_component)))
imkDf$rotated_y_acceleration = as.numeric(unlist(lapply(1:length(imkDf$t.m),rotated_y_component)))
imkDf$rotated_z_acceleration = as.numeric(unlist(lapply(1:length(imkDf$t.m),rotated_z_component)))


```

Init the state space models

```{r}

initial_orientation_state = c(
  params$x_initial_state_q0, 
  params$x_initial_state_q1,
  params$x_initial_state_q2,
  params$x_initial_state_q3,
  params$x_initial_state_euler_vx,
  params$x_initial_state_euler_vy,
  params$x_initial_state_euler_vz
)

initial_orientation_belief = diag(
  c(
    params$initial_belief_00_q0,  
    params$initial_belief_11_q1,
    params$initial_belief_22_q2,
    params$initial_belief_33_q3,
    params$initial_belief_44_euler_vx,
    params$initial_belief_55_euler_vy,
    params$initial_belief_66_euler_vz
    )
)

orientation_process_noise = data.frame(
  vx = params$process_noise_orientation_angular_velocity_sigma_x,
  vy = params$process_noise_orientation_angular_velocity_sigma_y,
  vz = params$process_noise_orientation_angular_velocity_sigma_z
)

orientation_sensor_noise = data.frame(
  vx = params$sensor_noise_imu_euler_velocity_x,
  vy = params$sensor_noise_imu_euler_velocity_y,
  vz = params$sensor_noise_imu_euler_velocity_z
)
#

processOrientationModel = getGuanglongOrientationModel(initial_orientation_state, initial_orientation_belief, orientation_process_noise, orientation_sensor_noise)

## only for simulation
rotationMatrix = quaternion_rotation_matrix(1,0,0,0)
##

#rotationMatrix = quaternion_rotation_matrix(imkDf$kinect_hand_right_orientation.w, imkDf$kinect_hand_right_orientation.x, imkDf$kinect_hand_right_orientation.y, imkDf$kinect_hand_right_orientation.z)

initial_matrixHandToLocal = data.frame(
  mx_x = rotationMatrix[1,1], my_x = rotationMatrix[1,2], mz_x = rotationMatrix[1,3],
  mx_y = rotationMatrix[2,1], my_y = rotationMatrix[2,2], mz_y = rotationMatrix[2,3],
  mx_z = rotationMatrix[3,1], my_z = rotationMatrix[3,2], mz_z = rotationMatrix[3,3]
)

initial_gravity = data.frame(
  x = imkDf$imu_gravity.x[1],
  y = imkDf$imu_gravity.y[1],
  z = imkDf$imu_gravity.z[1]
  )

## only for simalation
initial_gravity = data.frame(
  x = 0,
  y = 0,
  z = 1
  )
##

initial_acceleration_state = c(
  params$x_initial_state_px,  
  params$x_initial_state_vx,
  params$x_initial_state_ax,
  params$x_initial_state_py,  
  params$x_initial_state_vy,
  params$x_initial_state_ay,
  params$x_initial_state_pz,  
  params$x_initial_state_vz,
  params$x_initial_state_az
)

initial_acceleration_belief = diag(c(
  params$initial_belief_px_00,
  params$initial_belief_vx_11,
  params$initial_belief_ax_22,
  params$initial_belief_py_33,
  params$initial_belief_vy_44,
  params$initial_belief_ay_55,
  params$initial_belief_pz_66,
  params$initial_belief_vz_77,
  params$initial_belief_az_88
))

acceleration_process_noise = data.frame(
  x = params$process_noise_acceleration_noise_omega_x,
  y = params$process_noise_acceleration_noise_omega_y,
  z = params$process_noise_acceleration_noise_omega_z
)

acceleration_sensor_noise = data.frame(
  x = params$sensor_noise_kinect_sigma_x,
  y = params$sensor_noise_kinect_sigma_y,
  z = params$sensor_noise_kinect_sigma_z,
  ax = params$sensor_noise_imu_sigma_x,
  ay = params$sensor_noise_imu_sigma_y,
  az = params$sensor_noise_imu_sigma_z
)

processAccelerationModel = getGuanglongAccelerationModel(initial_acceleration_state, initial_acceleration_belief, initial_matrixHandToLocal, initial_gravity, acceleration_process_noise, acceleration_sensor_noise)

```

Apply Kalman Filter on models with data

```{r}

oMTMax = 1000 # orientationModelTimeMaximum


fkfGuanglongOrientationModel = fkf(
  a0 = processOrientationModel$x[,1],
  P0 = processOrientationModel$P,
  dt = matrix(data = 0, nrow = 7, ncol = 1),
  ct = matrix(data = 0, nrow = 3, ncol = 1),
  GGt = array(diag(nrow = 3, ncol = 3), dim=c(3,3,1)),
  Zt = array(processOrientationModel$H, dim=c(3,7,1)),
  Tt = array(as.numeric(unlist(lapply(1:1,orientation_transition_at_index))), dim=c(7, 7, oMTMax)),
  HHt = array(processOrientationModel$Q, dim=c(7,7,1)),
  yt = matrix(data = c(imkDfRaw$imu_yaw[oMTMax],imkDfRaw$imu_pitch[oMTMax],imkDfRaw$imu_pitch[oMTMax]), ncol = oMTMax, nrow = 3, byrow = TRUE)
  )

```

```{r}
aMTMax = 500 # accelerationModelTimeMaximum

diag(9) * 0.5

fkfGuanglongAccelerationModel = fkf(
  a0 = processAccelerationModel$x[,1],
  P0 = processAccelerationModel$P,
  dt = matrix(data = 0, nrow = 9, ncol = 1),
  ct = matrix(data = 0, nrow = 6, ncol = 1),
  GGt = diag(nrow = 6, ncol = 6),
  Zt = processAccelerationModel$H,
  Tt = array(as.numeric(unlist(lapply(1:aMTMax,acceleration_transition_at_index))), dim=c(9, 9, aMTMax)),
  HHt = processAccelerationModel$Q,
  yt = matrix(data = c(
    imkDf$kinect_hand_right.x[1:aMTMax],
    imkDf$kinect_hand_right.y[1:aMTMax],
    imkDf$kinect_hand_right.z[1:aMTMax],
    imkDf$imu_acceleration.x[1:aMTMax],
    imkDf$imu_acceleration.y[1:aMTMax],
    imkDf$imu_acceleration.z[1:aMTMax]
  ), nrow = 6, ncol = aMTMax, byrow = TRUE)
  )
```


Plot the data

```{r}

plot(imkDf$kinect_hand_right.x[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 20, main = "x", ylab = "x",xlab="time", type='l', ylim = c(-1, 1))
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[1,1,1:aMTMax] + fkfGuanglongAccelerationModel$att[1,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[1,1:aMTMax ] - fkfGuanglongAccelerationModel$Ptt[1,1,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[1, 1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$kinect_hand_right.x[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("p_x state", "kinect x"), lwd = 3, col = c("blue", "black"))


plot(imkDf$rotated_x_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 20, main = "a_x", ylab = "a_x",xlab="time", type='l')
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[1,1,1:aMTMax] + fkfGuanglongAccelerationModel$att[1,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[1,1:aMTMax] - fkfGuanglongAccelerationModel$Ptt[1,1,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[3,1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$rotated_x_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("a_x state", "imu x"), lwd = 3, col = c("blue", "black"))


plot(imkDf$kinect_hand_right.y[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 4, main = "y", ylab = "y",xlab="time", type='l')
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[2,2,1:aMTMax] + fkfGuanglongAccelerationModel$att[2,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[2,1:aMTMax] - fkfGuanglongAccelerationModel$Ptt[2,2,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[2,1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$kinect_hand_right.y[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("p_y state", "kinect y"), lwd = 3, col = c("blue", "black"))


plot(imkDf$rotated_y_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 20, main = "a_y", ylab = "a_y",xlab="time", type='l')
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[8,8,1:aMTMax] + fkfGuanglongAccelerationModel$att[8,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[8,1:aMTMax] - fkfGuanglongAccelerationModel$Ptt[8,8,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[8,1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$rotated_y_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("a_y state", "imu y"), lwd = 3, col = c("blue", "black"))


plot(imkDf$kinect_hand_right.z[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 4, main = "z", ylab = "z",xlab="time", type='l')
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[3,3,1:aMTMax] + fkfGuanglongAccelerationModel$att[3,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[3,1:aMTMax] - fkfGuanglongAccelerationModel$Ptt[3,3,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[3,1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$kinect_hand_right.z[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("p_z state", "z"), lwd = 3, col = c("blue", "black"))


plot(imkDf$rotated_z_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax], pch  = 20, main = "a_z", ylab = "a_z",xlab="time", type='l')
polygon(
  x = c(imkDf$t[1:aMTMax], rev(imkDf$t[1:aMTMax])),
  y = c(fkfGuanglongAccelerationModel$Ptt[9,9,1:aMTMax] + fkfGuanglongAccelerationModel$att[9,1:aMTMax], rev(fkfGuanglongAccelerationModel$att[9,1:aMTMax] - fkfGuanglongAccelerationModel$Ptt[9,9,1:aMTMax] )),
  col = "lightsteelblue",
  border = NA)
lines(fkfGuanglongAccelerationModel$att[9,1:aMTMax] ~ imkDf$t[1:aMTMax], col = "blue")
lines(imkDf$rotated_z_acceleration[1:aMTMax] ~ imkDf$t[1:aMTMax])
legend("bottomright", legend = c("a_z state", "imu z"), lwd = 3, col = c("blue", "black"))


plot(imkDfRaw$imu_yaw[1:oMTMax] ~ imkDf$t[1:oMTMax], pch  = 4, main = "yaw", ylab = "yaw",xlab="time", type='l')
lines(fkfGuanglongOrientationModel$att[5,1:oMTMax] ~ imkDf$t[1:oMTMax], col = "blue")

plot(imkDfRaw$imu_pitch[1:oMTMax] ~ imkDf$t[1:oMTMax], pch  = 4, main = "pitch", ylab = "pitch",xlab="time", type='l')
lines(fkfGuanglongOrientationModel$att[6,1:oMTMax] ~ imkDf$t[1:oMTMax], col = "blue")

plot(imkDfRaw$imu_roll[1:oMTMax] ~ imkDf$t[1:oMTMax], pch  = 4, main = "roll", ylab = "roll",xlab="time", type='l',  ylim = c(-70, 50))
lines(fkfGuanglongOrientationModel$att[7,1:oMTMax] ~ imkDf$t[1:oMTMax], col = "blue")

```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



